<!DOCTYPE html>
<html>

<head>
    <style>
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            text-align: center;
            color: #ffff00;
        }

        body {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="info">Game Physics</div>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

    <script>
        var camera, scene, renderer;
        var light1, light2, light3, light4, light5;
        // var ball1,ball2,ball3,ball4,ball5;
        var angle = 0;
        var a = 0;
        var balls = [];
        var walls = [];

        //var pos, vel, force;
        const R = 4;
        class Wall {
            constructor(pos,vel, mesh) {
                this.pos = pos;
                this.pos = pos;//位置
                this.vel = vel;//速度(Velocity)
                this.force = new THREE.Vector3(0, 0, 0);//力量
                this.mesh = mesh;
                scene.add(this.mesh);

                mesh.material.color = new THREE.Color().setHSL(Math.random(), 0.5, .7);//材料
                //mesh.material.wireframe = true;//網狀
            }

            update(dt) {
                this.vel.add(this.force.clone().multiplyScalar(dt));
                this.pos.add(this.vel.clone().multiplyScalar(dt));

                // wall-collision
                if (this.pos.y < -150 + R) {
                    this.vel.y = -this.vel.y;

                    this.pos.y = -150 + R;
                }
                if (this.pos.x > 150 - R) {
                    this.vel.x = -this.vel.x;

                    this.pos.x = 150 - R;
                }
                if (this.pos.x < -150 + R) {
                    this.vel.x = -this.vel.x;

                    this.pos.x = -150 + R;
                }

                this.mesh.position.copy(this.pos);
            }
        }

        class Ball {
            constructor(pos, vel, mesh) {
                this.pos = pos;//位置
                this.vel = vel;//速度(Velocity)
                this.force = new THREE.Vector3(0, 0, 0);//力量
                this.mesh = mesh;
                scene.add(this.mesh);

                mesh.material.color = new THREE.Color().setHSL(Math.random(), 0.5, .7);//材料
                //mesh.material.wireframe = true;//網狀
            }

            update(dt) {
                this.vel.add(this.force.clone().multiplyScalar(dt));
                this.pos.add(this.vel.clone().multiplyScalar(dt));

                // wall-collision
                if (this.pos.y < -40 + R) {
                    this.vel.y = -this.vel.y;

                    this.pos.y = -40 + R;
                }
                if (this.pos.x > 40 - R) {
                    this.vel.x = -this.vel.x;

                    this.pos.x = 40 - R;
                }
                if (this.pos.x < -40 + R) {
                    this.vel.x = -this.vel.x;

                    this.pos.x = -40 + R;
                }

                this.mesh.position.copy(this.pos);
            }
        }




        function buildBallMesh(mycolor) {
            let ballMesh = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 20), new THREE.MeshPhongMaterial());
            ballMesh.material.color = mycolor;
            return ballMesh;
        }

        // function buildWallMesh(mycolor) {
        //     let wallMesh = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshPhongMaterial());
        //     wallMesh.material.color = mycolor;
        //     return wallMesh;
        // }

        //////////////////////////////////////////////////
        init();
        animate();

        function init() {
            renderer = new THREE.WebGLRenderer({
                antialias: true,
            });

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x888888);
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            //camera = new THREE.OrthographicCamera(-50, 50, 50, -50, -10, 100);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 200;
            // camera.position.set(50, 100, 100);
            let grid = new THREE.GridHelper(200, 20, "red", "white");
            let controls = new THREE.OrbitControls(camera, renderer.domElement);

            scene.add(grid); //線網

            //地板
            // var floor = new THREE.Mesh(new THREE.BoxGeometry(150, 5, 130), new THREE.MeshPhongMaterial({ color: 0xD3D3D3, transparent: true, opacity: 0.9 }));
            // floor.position.set(0, 5 / 2, 0);
            // var wallL = new THREE.Mesh(new THREE.BoxGeometry(130, 5, 25), new THREE.MeshPhongMaterial({ color: 0xD3D3D3, transparent: true, opacity: 0.4 }));
            // wallL.rotation.x = -Math.PI / 2;//旋轉角度
            // wallL.rotation.z = -Math.PI / 2;//旋轉角度
            // wallL.position.set(-150 / 2, 25 / 2, 0);

            // var wallR = new THREE.Mesh(new THREE.BoxGeometry(130, 5, 25), new THREE.MeshPhongMaterial({ color: 0xD3D3D3, transparent: true, opacity: 0.4 }));
            // wallR.rotation.x = -Math.PI / 2;//旋轉角度
            // wallR.rotation.z = -Math.PI / 2;//旋轉角度
            // wallR.position.set(150 / 2, 25 / 2, 0);

            // var wallB = new THREE.Mesh(new THREE.BoxGeometry(155, 5, 25), new THREE.MeshPhongMaterial({ color: 0xD3D3D3, transparent: true, opacity: 0.4 }));
            // wallB.rotation.x = -Math.PI / 2;//旋轉角度
            // wallB.position.set(0, 25 / 2, -130 / 2)



            // scene.add(floor, wallL, wallR, wallB);




            // let wallMesh = buildWallMesh(new THREE.Color().setHSL(Math.random(), 0.9, 0.4));

            let floor = new Ball(new THREE.Vector3(0, 5/2, 0),new THREE.Vector3(0, 0, 0), new THREE.Mesh(new THREE.BoxGeometry(150, 5, 120), new THREE.MeshPhongMaterial({ color: 0xD3D3D3, transparent: true, opacity: 0.9 })));
            // floor.pos.set(0, 5 / 2, 0);
            walls.push(floor);

            let wallL = new Ball(new THREE.Vector3(-150/2, 0, 0), new THREE.Vector3(0, 0, 0),new THREE.Mesh(new THREE.BoxGeometry(5, 25, 120), new THREE.MeshPhongMaterial({ color: 0xD3D3D3, transparent: true, opacity: 0.9 })));
            // // wallL.rotation.x = -Math.PI / 2;//旋轉角度
            // wallL.rotation.z = -Math.PI / 2;//旋轉角度
            // wallL.pos.set(-130, 25 / 2+5, 0);
            walls.push(wallL);

            // let wallR = new Ball(new THREE.Vector3(130, 5, 25), new THREE.Vector3(0, 0, 0),new THREE.Mesh(new THREE.BoxGeometry(130, 5, 25), new THREE.MeshPhongMaterial({ color: 0xD3D3D3, transparent: true, opacity: 0.9 })));
            // // walls.push(wallR);

            // let wallB = new Ball(new THREE.Vector3(155, 5, 25), new THREE.Vector3(0, 0, 0), new THREE.Mesh(new THREE.BoxGeometry(155, 5, 25), new THREE.MeshPhongMaterial({ color: 0xD3D3D3, transparent: true, opacity: 0.9 })));
            // // walls.push(wallB);

            // let wallF = new Ball(new THREE.Vector3(155, 5, 25), new THREE.Vector3(0, 0, 0), new THREE.Mesh(new THREE.BoxGeometry(155, 5, 25), new THREE.MeshPhongMaterial({ color: 0xD3D3D3, transparent: true, opacity: 0.9 })));
            // walls.push(wallF);



            // ball1 = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 40), new THREE.MeshPhongMaterial({color:0xd4fc79}));
            // ball1.position.set(30, 1.5+5, 0);
            // ball1.material.emissive = new THREE.Color(0xd4fc79);

            // ball2 = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 40), new THREE.MeshPhongMaterial({color:0xa1c4fd}));
            // ball2.position.set(-30, 1.5+5, 0);
            // ball2.material.emissive = new THREE.Color(0xa1c4fd);


            // ball3 = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 40), new THREE.MeshPhongMaterial({color:0xfccb90}));
            // ball3.position.set(0, 1.5+5, 30);
            // ball3.material.emissive = new THREE.Color(0xfccb90);


            // ball4 = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 40), new THREE.MeshPhongMaterial({color:0xfad0c4}));
            // ball4.position.set(0, 1.5+5, -30);
            // ball4.material.emissive = new THREE.Color(0xfad0c4);


            // ball5 = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 40), new THREE.MeshPhongMaterial({color:0xffb2b2}));
            // ball5.position.set(25, 1.5+5, 25);
            // ball5.material.emissive = new THREE.Color(0xffb2b2);


            // scene.add(ball1, ball2, ball3, ball4, ball5);

            //固定光白
            pointLight = new THREE.PointLight();
            scene.add(pointLight, new THREE.PointLightHelper(pointLight, 4));
            //固定光暗色
            pointLightDark = new THREE.AmbientLight(0x000000);
            scene.add(pointLightDark, new THREE.PointLightHelper(pointLightDark, 4));



            //跟隨光
            light1 = new THREE.PointLight(0xd4fc79);
            // scene.add(light1, new THREE.PointLightHelper(light1, 4));

            light2 = new THREE.PointLight(0xa1c4fd);
            // scene.add(light2, new THREE.PointLightHelper(light2, 4));

            light3 = new THREE.PointLight(0xfccb90);
            // scene.add(light3, new THREE.PointLightHelper(light3, 4));

            light4 = new THREE.PointLight(0xfad0c4);
            // scene.add(light4, new THREE.PointLightHelper(light4, 4));

            light5 = new THREE.PointLight(0xffb2b2);
            // scene.add(light5, new THREE.PointLightHelper(light5, 4));
            scene.add(light1, light2, light3, light4, light5);



            ballMesh = buildBallMesh(new THREE.Color().setHSL(Math.random(), 0.9, 0.4));

            let ball1 = new Ball(new THREE.Vector3(30, 6.5, 0), new THREE.Vector3(0, 0, 0), ballMesh);
            balls.push(ball1);
            ballMesh = buildBallMesh(new THREE.Color().setHSL(Math.random(), 0.9, 0.4));

            let ball2 = new Ball(new THREE.Vector3(-30, 6.5, 0), new THREE.Vector3(0, 0, 0), ballMesh);
            balls.push(ball2);
            ballMesh = buildBallMesh(new THREE.Color().setHSL(Math.random(), 0.9, 0.4));

            let ball3 = new Ball(new THREE.Vector3(0, 6.5, 30), new THREE.Vector3(0, 0, 0), ballMesh);
            balls.push(ball3);
            ballMesh = buildBallMesh(new THREE.Color().setHSL(Math.random(), 0.9, 0.4));

            let ball4 = new Ball(new THREE.Vector3(0, 6.5, -30), new THREE.Vector3(0, 0, 0), ballMesh);
            balls.push(ball4);
            ballMesh = buildBallMesh(new THREE.Color().setHSL(Math.random(), 0.9, 0.4));

            let ball5 = new Ball(new THREE.Vector3(25, 6.5, 25), new THREE.Vector3(0, 0, 0), ballMesh);
            balls.push(ball5);
            ballMesh = buildBallMesh(new THREE.Color().setHSL(Math.random(), 0.9, 0.4));


            window.addEventListener("resize", onWindowResize, false);
            //window.addEventListener('mousedown', onDocumentMouseDown, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();

            angle += 0.1;
            pointLight.position.set(-40, 10, -30);
            pointLightDark.position.set(30, 10, 40);

            a += 0.1;
            // ball1.position.set(30+50*Math.cos(a), 5.5, 0+50*Math.sin(a));
            // ball2.position.set(-30+50*Math.cos(a), 5.5, 0+50*Math.sin(a));

            // ballLight1
            // light1.position.copy(ball1.position);
            // light2.position.copy(ball2.position);
            // light3.position.copy(ball3.position);
            // light4.position.copy(ball4.position);
            // light5.position.copy(ball5.position);

            var dt = 0.1;
            for (let i = 0; i < walls.length; i++)
                walls[i].update(100);

            var dt1 = 0.1;
            for (let i = 0; i < balls.length; i++)
                balls[i].update(dt1);




            /*
            vel.add (force.clone().multiplyScalar (dt));
              pos.add (vel.clone().multiplyScalar (dt));


              if (pos.y < -40+R) {
                     vel.y = - vel.y;

                 pos.y = -40+R;
              }
              if (pos.x > 40-R) {
                     vel.x = - vel.x;

                 pos.x = 40-R;
              }
             if (pos.x < -40+R) {
                     vel.x = - vel.x;

                 pos.x = -40+R;
              }

                ball.position.copy (pos);
             */

        }

        function render() {
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>