<!DOCTYPE html>
<html>

<head>
    <style>
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            text-align: center;
            color: #ffff00;
        }

        body {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="info">Game Physics</div>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

    <script>
        var camera, scene, renderer;
        var pointLight;
        var angle = 0;
        var balls = [];

        //var pos, vel, force;
        const R = 4;

        class Ball {
            constructor(pos, vel, mesh) {
                this.pos = pos;
                this.vel = vel;
                this.force = new THREE.Vector3(0, 0, 0);
                this.mesh = mesh;
                scene.add(this.mesh);

                mesh.material.color = new THREE.Color(0xff9a9e);
                //mesh.material.wireframe = true;//網狀
            }

            update(dt) {
                this.vel.add(this.force.clone().multiplyScalar(dt));
                this.pos.add(this.vel.clone().multiplyScalar(dt));

                // wall-collision
                if (this.pos.y < -40 + R) {
                    this.vel.y = -this.vel.y;

                    this.pos.y = -40 + R;
                }
                if (this.pos.x > 40 - R) {
                    this.vel.x = -this.vel.x;

                    this.pos.x = 40 - R;
                }
                if (this.pos.x < -40 + R) {
                    this.vel.x = -this.vel.x;

                    this.pos.x = -40 + R;
                }

                this.mesh.position.copy(this.pos);
            }
        }

        function buildBallMesh(mycolor) {
            let ballMesh = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 20), new THREE.MeshBasicMaterial());
            ballMesh.material.color = mycolor;
            return ballMesh;
        }

        //////////////////////////////////////////////////
        init();
        animate();

        function init() {
            renderer = new THREE.WebGLRenderer({
                antialias: true,
            });

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x888888);
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            //camera = new THREE.OrthographicCamera(-50, 50, 50, -50, -10, 100);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 200;
            // camera.position.set(50, 100, 100);
            let grid = new THREE.GridHelper(200, 20, "red", "white");

            scene.add(grid); //線網

            //地板
            var floor = new THREE.Mesh(new THREE.BoxGeometry(150, 5, 130), new THREE.MeshPhongMaterial());
            floor.position.set(0, 5 / 2, 0);
            var wallL = new THREE.Mesh(new THREE.BoxGeometry(130, 5, 25), new THREE.MeshPhongMaterial({ color:0xD3D3D3}));
            wallL.rotation.x = -Math.PI / 2;//旋轉角度
            wallL.rotation.z = -Math.PI / 2;//旋轉角度
            wallL.position.set(-150 / 2, 25 / 2, 0);

            var wallR = new THREE.Mesh(new THREE.BoxGeometry(130, 5, 25), new THREE.MeshPhongMaterial());
            wallR.rotation.x = -Math.PI / 2;//旋轉角度
            wallR.rotation.z = -Math.PI / 2;//旋轉角度
            wallR.position.set(150 / 2, 25 / 2, 0);

            var wallB = new THREE.Mesh(new THREE.BoxGeometry(155, 5, 25), new THREE.MeshPhongMaterial());
            wallB.rotation.x = -Math.PI / 2;//旋轉角度
            wallB.position.set(0, 25 / 2, -130 / 2)



            scene.add(floor, wallL, wallR, wallB);


            var ball1 = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 40), new THREE.MeshNormalMaterial());
            ball1.position.set(30, 1.5, 0);

            var ball2 = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 40), new THREE.MeshPhongMaterial());
            ball2.position.set(-30, 1.5, 0);

            var ball3 = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 40), new THREE.MeshBasicMaterial());
            ball3.position.set(0, 1.5, 30);

            var ball4 = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 40), new THREE.MeshBasicMaterial());
            ball4.position.set(0, 1.5, -30);

            var ball5 = new THREE.Mesh(new THREE.CylinderGeometry(R, R, 3, 40), new THREE.MeshBasicMaterial());
            ball5.position.set(25, 1.5, 25);

            scene.add(ball1, ball2, ball3, ball4, ball5);


            var pointLight = new THREE.PointLight();
            pointLight.position.set(0, 30, 0);//固定位置的光源
            scene.add(pointLight, new THREE.PointLightHelper(pointLight, 4));

            let controls = new THREE.OrbitControls(camera, renderer.domElement);


            let ballMesh = buildBallMesh(new THREE.Color().setHSL(Math.random(), 0.9, 0.4));

            let ball = new Ball(new THREE.Vector3(0, 1.5, 0), new THREE.Vector3(0, 0, 0), ballMesh);
            balls.push(ball);

            ballMesh = buildBallMesh(new THREE.Color().setHSL(Math.random(), 0.9, 0.4));


            window.addEventListener("resize", onWindowResize, false);
            //window.addEventListener('mousedown', onDocumentMouseDown, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();

            angle += 0.1;
            pointLight.position.set(50 * Math.cos(angle), 30, 50 * Math.sin(angle));

        }

        function render() {
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>